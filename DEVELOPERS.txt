/************************************************* Part2 begin *************************************************/
/*
    @author: Omar Muhammetkulyyev
*/
advanceMain.c:
    /* Simulation of a Klondike Solitaire with Part1 and Part2 (not finished yet).
    * Takes in any game configuration and determines if it has formatting error,
    * or invalid input for the current game state. If none of these happen,
    * then the program parses the input completely and outputs the final state
    * of the game. Note the game outputs the final configuration even if
    * invalid input were encountered, in which case it first prints out the
    * number of the invalid move and then the state of the game paused at that
    * instant. If -m N switch is provided, the program processes at most N
    * moves from the given initial MOVES: section; If -m N is ommitted this numer
    * is set to INFINITY or unlimited moves. If -x is provided, the program
    * outputs the final state in exchange format instead of human-readable format
    * when omitted. Outputs to a given file by -o fileName switch or stdout if omitted.
    * @param argc: number of the command line arguments
    * @param argv: array of strings that represent command line arguments
    * @return 0 if the program is successfully executed
    * */
    int main(int argc, char* argv[]){ }

/*
    @author: Omar Muhammetkulyyev
*/
part2.h:
    // Useful constant
    #define INF 1e6+7
    
    /* This is the second part of COMS327S20 Project. Takes in the given
    * state of the game until "MOVES:" section, and processes the section
    * until the end of file. If there is a formatting error, line number of
    * the illegal format is printed out. If the format is correct but the
    * input is invalid for the current state of the game, the move number
    * is printed out. If there is neither formatting error nor invalid input
    * then total number of processed moves is printed out.
    * @param inFile: given file buffer to read the data from
    * @param tableau: literal tableau of cards of the given state of the game
    * @param tSize: contains sizes of each columns of tableau
    * @param cSize: contains sizes of covered cards in each column of the tableau
    * @param waste: contains the cards that are in the waste currently. Last card of 
    *               the array is the topmost card in the waste
    * @param wasteSize: size of the waste array
    * @param stock: contains the cards that are in the stock currently. Last card of
    *               the array is the topmost card in the stock
    * @param stockSize: size of the stock array
    * @param found: contains cards that are in 4 foundations.
    * @param fSize: the size of the each foundation
    * @param turns: number of the cards that are turned over from stock to the waste
    * @param limit: max number of times the waste can be reset back to the stock. Usually
    *               is in between 0 and 9. Indicates infinity (unlimited) if 10.
    * @param lcount: current line number before processing MOVES section
    * @return 1 if the file has been successfully read, 0 if there is a formatting error
    *         or -1 if the provided move is not valid for that instant of the game state
    * */
    int part2(FILE* inFile, int maxMoves, struct Card tableau[][MAX_CARD], int tSize[COLUMN], int cSize[COLUMN], 
            struct Card waste[MAX_CARD], int* wasteSize, struct Card stock[MAX_CARD], int* stockSize, struct Card found[MAX_FOUND][MAX_CARD], 
            int fSize[MAX_FOUND], int* turns, int* limit, int* lcount);

/*
    @author: Omar Muhammetkulyyev
*/
part2.c:
    //keeping the # of curline
    int lineCount;
    
    /* Returns the minimum of the two input parameters
    * @param x: first integer to compare
    * @param y: second integer to compare
    * @return the value of them minimum of the two given integers
    * */
    int min(int x, int y){ }
    
    /*
        Please refer to part2.h for the documentation
    */
    int part2(FILE* inFile, int maxMoves, struct Card tableau[][MAX_CARD], int tSize[COLUMN], int cSize[COLUMN], 
          struct Card waste[MAX_CARD], int* wasteSize, struct Card stock[MAX_CARD], int* stockSize, struct Card found[MAX_FOUND][MAX_CARD], 
          int fSize[MAX_FOUND], int* turns, int* limit, int* lcount){ }

/************************************************* Part2 end *************************************************/

/************************************************* Part1 begin *************************************************/

/*
    @author: Omar Muhammetkulyyev
*/
checkMain.c:
	/*
        Simple (incomplete) simulation of Klondike Solitaire.
        Takes in parameter (filename in our case) from the command line
        and calls the respective parts of the main project. (i.e there is
        only part1 implemented)
    */
	int main(int argc, char* argv[]);

/*
    @author: Omar Muhammetkulyyev
*/
part1.h:
    /* 
        struct that represents a card with member variables: suit, rank and color
    */
    struct Card{ };
    
    /*
        Some useful global variables:
    */
    #define MAX_CARD 70     // maximum number of cards that can be present
    #define MAX_FOUND 4     // max number of foundations
    #define COLUMN 7        // max number of columns in tableau
    
    /*
        Documentation for the following helper functions are provided in part1.c
    */
    int isSpace(int ch);
    int hasNext(FILE* inFile, int* lcount);
    int getNext(FILE* inFile, char str[]);
    int isEqual(char a[], const char b[]);
    void skipLine(FILE* inFile);
    int isDigit(char a[]);
    int getSuit(char a);
    int getRank(char a);
    int getColor(char a);
    int isValidCard(char a[]);
    
    /*
        Prototype of the part1 function that is implemented in part1.c.
        Simply implements all the features required for part1 of this project.
        Please refer to the documentation in part1.h
    */
    int part1(FILE* inFile, struct Card tableau[][MAX_CARD], int tSize[COLUMN], int cSize[COLUMN], struct Card waste[MAX_CARD], int* wasteSize,
              struct Card stock[MAX_CARD], int* stockSize, struct Card found[MAX_FOUND][MAX_CARD], int fSize[MAX_FOUND], int* turns, 
              int* limit, int* lcount);

/*
    @autor: Omar Muhammetkulyyev
*/
part1.c:
    // Useful constants
    const char keys[][MAX_CHAR] = {"RULES:", "FOUNDATIONS:", "TABLEAU:", "STOCK:", "MOVES:"};
    const char ranks[] = "_A23456789TJQK";
    const char suits[] = "cdhs";

    // Keeps track of the line number to report error
    int lineCount = 1;

    // Global variables to keep track of the game mode: turn number and limit of resetting the waste back to the stock
    int turns, limit;

    // Global helper array
    int allCard[4][15];

    // Global arrays to keep track of the tableau, waste, stock and foundation respectively
    struct Card tableau[COLUMN][MAX_CARD], waste[MAX_CARD], stock[MAX_CARD], found[MAX_FOUND][MAX_CARD];

    // Global arrays to keep track of the size of the tableau columns, tableau seperators, waste, stock and foundation respectively
    int tSize[COLUMN], cSize[COLUMN], wasteSize, stockSize, fSize[MAX_FOUND];

    /* Checks if the given character is a space (either one of ' ', '\t',
     * '\r' and '\n')
     * @param ch: given character
     * @return 1 if the character is a space, 0 otherwise
     * */
    int isSpace(int ch){ }

    /* Checks if there exists any non-space character in the given file buffer
     * @param inFile: file to read the data from
     * @return 1 if the buffer contains non-space character, 0 otherwise
     * */
    int hasNext(FILE* inFile){ }

    /* Scans in the next non-space sequence of characters into the provided
     * string (str). Stops scanning into the string if the length of the word
     * exceeds MAX_CHAR-1. Assigns \0 to the end of the string (null termination)
     * @param inFile: given file to read data from
     * @param str: given string to scan data into
     * @return the size of the scanned word
     * */
    int getNext(FILE* inFile, char str[]){ }

    /* Checks if the two given strings are equal
     * @param a: given first string
     * @param b: given second string
     * @return 1 if the strings are equal, 0 otherwise
     * */
    int isEqual(char a[], const char b[]){ }

    /* Skips all the characters until reaches a new line '\n', in which case
     * ungets it and retains '\n' untouched in buffer
     * @param inFile: given file to read from
     * */
    void skipLine(FILE* inFile){ }

    /* Checks if the given string is a digit
     * @param a: given string
     * @return 1 if the string is between 0 <= string <= 9, 0 otherwise
     * */
    int isDigit(char a[]){ }

    /*
     * Evaluates the RULES module
     * @param inFile: given file to read data from
     * @return 1 if the given module is valid, 0 otherwise
     * */
    int rules(FILE* inFile){ }

    /* Returns the suit of the card
     * @param a: given suit of the card in char format
     * @return the corresponsing index of occurrence in "cdhs", -1 if not found
     * */
    int getSuit(char a){ }

    /* Returns the rank of the card
     * @param a: given rank of the card in char format
     * @return the corresponsing index of occurrence in "_A23456789TJQK", -1 if not found
     * */
    int getRank(char a){ }

    /* Returns the color of the suit
     * @param a: suit of the card
     * @return -1 if black, 1 otherwise
     * */
    int getColor(char a){ }

    /* Checks for validity of the card
     * @param a: given card in form of a string
     * @return 1 if the given string is indeed card, 0 otherwise
     * */
    int isValidCard(char a[]){ }
    
    /* Checks for duplicates
     * @param a: given card
     * @return true if the given card has been seen before, false otherwise
     * */
    int isDuplicate(struct Card a){ }

    /*
     * Evaluates the FOUNDATION module
     * @param inFile: given file to read data from
     * @return 1 if the given module is valid, 0 otherwise
     * */
    int foundation(FILE* inFile){ }
    
    /*
     * Evaluates the TABLEAU module
     * @param inFile: given file to read data from
     * @return 1 if the given module is valid, 0 otherwise
     * */
    int table(FILE* inFile){ }

    /*
     * Evaluates the STOCK module
     * @param inFile: given file to read data from
     * @return 1 if the given module is valid, 0 otherwise
     * */
    int stockAndWaste(FILE* inFile){ }
    
    /*
        Please refer to documentation in part1.h
    */
    int part1(FILE* inFile, struct Card gtableau[][MAX_CARD], int gtSize[COLUMN], int gcSize[COLUMN], struct Card gwaste[MAX_CARD], int* gwasteSize,
            struct Card gstock[MAX_CARD], int* gstockSize, struct Card gfound[MAX_FOUND][MAX_CARD], int gfSize[MAX_FOUND], 
            int* gturns, int* glimit, int* lcount){ }

/************************************************* Part1 end *************************************************/
